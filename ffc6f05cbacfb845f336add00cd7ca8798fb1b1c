Revision: ffc6f05cbacfb845f336add00cd7ca8798fb1b1c
Patch-set: 2
File: /COMMIT_MSG

9
Tue Nov 24 01:09:13 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1b153384_fe85e1ed
Bytes: 59
Describe the bug. The bug number is useless outside Google.

9
Tue Nov 24 01:30:37 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1b153384_fe85e1ed
UUID: 9b2123e5_725ac532
Bytes: 39
Will provide more context w/next patch.

File: drivers/android/binder.c

2414
Tue Nov 24 01:43:13 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3b167790_bfc087ff
Bytes: 28
why are you allocating this?

2414
Tue Nov 24 18:05:14 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3b167790_bfc087ff
UUID: 3b167790_da54714c
Bytes: 196
for use in the below memcpy() and copy_to_user(), which needs to copy over aligned chunks.  I could instead copy over the original secctx and then add appropriate padding, but this seemed simpler.

2414
Tue Nov 24 22:31:31 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3b167790_da54714c
UUID: db271bf3_34c67dbf
Bytes: 53
why does memcpy and copy_to_user need aligned chunks?

2414
Wed Nov 25 23:06:27 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db271bf3_34c67dbf
UUID: 9b2123e5_dd0d7dbe
Bytes: 234
in Parcel.cpp, Parcel::read() pads all reads from the bwr.read_buffer with pad_size(), as does bio_alloc() and bio_get() in servicemanager/binder.c, although those latter two are for the br_transaction data rather than the bwr buffer.

2414
Wed Nov 25 23:35:17 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9b2123e5_dd0d7dbe
UUID: 3b167790_62ecafea
Bytes: 138
That does not mean you need to copy an aligned chunk. You can copy the data you have, and then align the pointer (or fill the pad region).

2414
Thu Nov 26 00:50:38 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3b167790_62ecafea
UUID: bbc4277e_a2655f24
Bytes: 470
Yes, that was the alternative I mentioned above (forgo the kzalloc and instead do copy_to_user() directly with secctx, followed by padding # of *ptr=0 statements).  Just to be clear: the issue here is one of efficiency, right? Were we to do it this way, we'd cut out a kzalloc and memcpy at the expense of only a couple of assignment and increment operations.  But in either case we need to update the ptr to account for the extra bytes that will be burned by userspace.

2414
Thu Nov 26 01:14:58 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bbc4277e_a2655f24
UUID: bb2a67bd_a1922939
Bytes: 214
It is not just an efficiency issue. You also added new error return path here that is different from everything else in this function. The only direct return paths here is if user space passed a bad buffer pointer.

2414
Thu Nov 26 01:21:44 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bb2a67bd_a1922939
UUID: 5b1b2bb8_1da55920
Bytes: 106
Got it.  Thank you for pointing that out; will switch in the next patch, again pending further discussion.

2447:6-2447:27
Sat Nov 21 01:38:45 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3b167790_6bbbf532
Bytes: 63
could send w/BR_REPLY too, but I don't have a use for that yet.

2451
Tue Nov 24 01:48:00 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db271bf3_84461a34
Bytes: 86
why are you using a different copy_to_user function than everything else in this file?

2451
Tue Nov 24 18:05:14 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db271bf3_84461a34
UUID: fbb05f0b_8f2ba55e
Bytes: 87
Hasty port from device-specific kernel in which patch was tested, which used this form.

2453
Tue Nov 24 01:48:00 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db271bf3_a42cfe6d
Bytes: 51
you may be writing past the end of the buffer here.

2453
Tue Nov 24 18:05:14 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db271bf3_a42cfe6d
UUID: 9b2123e5_a569993e
Bytes: 117
Yes, looks like a slightly messy addition above to go along with "if (end - ptr < sizeof(tr) + 4)" would be required.

2455
Tue Nov 24 01:09:13 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1b153384_9e614d18
Bytes: 51
This is inconsistent with the rest of the protocol.

2455
Tue Nov 24 01:30:37 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1b153384_9e614d18
UUID: db271bf3_e4139640
Bytes: 495
Yes.  As described in the bug, I came up with two approaches.  The first would be to add a field to br_transaction_data and pass the u32 sid along with it, but this is an opaque value with meaning only to the kernel and so would also require opening up an API to query this value.  It seemed simpler and more straightforward to just pass the string along with the transaction. I'd appreciate alternative suggestions if you have them, including perhaps a way to make this approach more palatable.

2455
Tue Nov 24 01:43:13 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db271bf3_e4139640
UUID: 5b1b2bb8_8d4ac256
Bytes: 396
That is not what I mean. The size of each command is encoded in the opcode. You changed the size of BR_TRANSACTION so that it no longer matches the size encoded in the opcode. If you want to pass more data in BR_TRANSACTION than BR_REPLY, then the opcode could be defined using a struct that contains that new data, but since you are a passing a variable length structure, that does not fit well.

2455
Tue Nov 24 18:05:14 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5b1b2bb8_8d4ac256
UUID: fbf69f9c_544fbd12
Bytes: 411
I see. It didn't look to me like we actually used that, so I thought this might be ok. As you mentioned, maintaining that set-up is problematic with the variable-length approach.

I don't like the idea of setting aside max-length structure in addition to the binder_transaction_data, so I guess we would have to add a struct which specifies strlen and a pointer to the string in the mmap'ed binder_proc->buffer?

2455
Tue Nov 24 22:31:31 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fbf69f9c_544fbd12
UUID: 1b153384_2b545aa7
Bytes: 175
You can look at other drivers for how to define a variable size IOC command (e.g. include/uapi/linux/hiddev.h), but it is probably best to add a separate return type for this.

2455
Wed Nov 25 23:06:27 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1b153384_2b545aa7
UUID: 1b153384_5f886c09
Bytes: 443
Thanks for the pointer, the  HIDIO[CG|CS]USAGES ioctls correspond, I think, to my suggestion of using a MAX_LEN.

I may be misunderstanding how we'd use a new return type, but the purpose of this patch would be to introduce an access control hook for binder transactions themselves, and so that information would need to be transferred as part of the BR_TRANSACTION payload and processed before the whole BR_TRANSACTION handling code finished.

2455
Wed Nov 25 23:35:17 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1b153384_5f886c09
UUID: fbb05f0b_5aa2f46a
Bytes: 258
Look at HIDIOCGNAME and HIDIOCGPHYS for examples of variable sized data. It is possible to have a variable sized transaction struct but it may be better to pass extra data with a separate return code so the encoded length is simply the string length or size.

2455
Thu Nov 26 00:50:38 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fbb05f0b_5aa2f46a
UUID: bbc4277e_022e4b81
Bytes: 754
I noticed HIDIOCGNAME & HIDIOCGPHYS as well, but if we were to use those, we would then have to start using the _IOC_[TYPE|NR|SIZE]  macros in userspace to decode these values to get at their constituent parts, whereas now they are simply used as constants.  I guess this is the fundamental issue; if the size field is supposed to matter, then we should be using it in userspace rather than treating these values as arbitrarily generated constants. 

Using a separate, new return value also breaks the current userspace usage pattern because we would be generating a binder protocol return code which has no meaning on its own, or put another way, how should executeCommand() respond when it receives BR_STRING_LEN not immediately after a BR_TRANSACTION?

2455
Thu Nov 26 01:14:58 2015 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bbc4277e_022e4b81
UUID: 1b153384_df861c83
Bytes: 159
I think someone from the framework team should look at what they prefer. (you could return the string before BR_TRANSACTION if that makes the decoding simpler)

2455
Thu Nov 26 01:21:44 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1b153384_df861c83
UUID: 1b153384_1fd6f473
Bytes: 131
SGTM.  I'll set something up w/ctate@ and also begin an enquiry w/paul moore when we return next week.  Thanks again for the input.

File: include/uapi/linux/android/binder.h

42:1-42:17
Sat Nov 21 01:38:45 2015 +0000
Author: Daniel Cashman <1026058@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5b1b2bb8_4fad65aa
Bytes: 107
intention is to use this in servicemanager/binder.c and Parcel.cpp instead of the current hard-coding of 3.

