Revision: 3eec5989cc6ff5f8e4403ed19eec435c4ef85af1
Patch-set: 1
File: /COMMIT_MSG

10
Thu Nov 01 21:54:04 2012 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAALP3///u0=
Bytes: 4
why?

10
Thu Nov 01 22:00:02 2012 +0000
Author: Todd Poynor <1004277@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAALP3///u0=
UUID: AAALPH//+58=
Bytes: 370
In hopes of avoiding idle wakeups that do nothing other than run the governor worker to find out the system is very idle -- stretch the next governor timer wakeup to the next timer run.  The ondemand governor does this as well.  It tends to save power in certain use cases, although performance impacts are still being evaluated.

Do you want this in the commit message?

10
Fri Nov 02 00:13:02 2012 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAALPH//+58=
UUID: AAALP3///pk=
Bytes: 513
Yes, but I don't think this justifies moving from a timer to a work queue. There are three independent changes here. Running the timer on the same cpu, using a deferred timer, and running the timer in thread context. The first seems reasonable on any system (however, it my not make any practical difference if the timer ends up running on the same cpu anyway). The second should only happen on systems where the frequency does not affect idle power consumption. The last change does not seem to have any benefit.

File: drivers/cpufreq/cpufreq_interactive.c

765
Thu Nov 01 14:20:09 2012 +0000
Author: Chris Fries <1004359@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAALMn///5w=
Bytes: 67
What's the advantage of deferrable work vs init_timer_deferrable()?

765
Thu Nov 01 18:30:54 2012 +0000
Author: Todd Poynor <1004277@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAALMn///5w=
UUID: AAALPH///P8=
Bytes: 193
I chose it mainly for the schedule_delayed_work_on() interface for CPU affinity, to keep the timers on the same CPU as being managed, maybe a little cache affinity, but probably not a big deal.

