Revision: 421336118f2376c540befe0cf905c5f1fad3534e
Patch-set: 13
File: security/selinux/avc.c

76
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_0a663b51
Bytes: 225
Potentially confusing to use the same field name as above.
od_head would be more accurate IIUC; this points to the first/head avc_operation_decision_node which in turn contains its own od_list link to the next one, and so on.

238
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_bff13f6a
Bytes: 12
Unnecessary.

266
Mon Mar 23 18:54:18 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_d18ce489
Bytes: 43
Might as well just make this unconditional.

293
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_4a9953c5
Bytes: 12
Unnecessary.

306
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_8d340510
Bytes: 46
Just dest->allowed->perms, src->allowed->perms

392
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_7fbb2754
Bytes: 12
Unnecessary.

512
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_aa5baf8c
Bytes: 13
Extra newline

529
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_8a606b32
Bytes: 13
Extra newline

533
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_ea55a756
Bytes: 30
Unnecessary whitespace change.

650
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_7f9207d4
Bytes: 90
No need/unsafe to goto found - lock not yet assigned or locked; just return NULL directly.

852
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_11578c2c
Bytes: 30
check and handle return value.

852
Mon Mar 23 18:54:18 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66a67829_11578c2c
UUID: 260c80ed_a207649c
Bytes: 113
Define and use a new event value for this and handle it in the switch statement, e.g. AVC_CALLBACK_ADD_OPERATION.

858
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_5f1e23e7
Bytes: 123
Shouldn't that be !(flags & AVC_NO_CMD)?  Or alternatively (flags & AVC_CMD) if using the flag to indicate presence of cmd?

858
Mon Mar 23 18:54:18 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 260c80ed_5f1e23e7
UUID: 66a67829_31a288ef
Bytes: 98
Rather than using flags, you could use a different AVC_CALLBACK_* event code when adding commands.

858
Mon Mar 23 18:58:49 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66a67829_31a288ef
UUID: 46d7b47e_4dfded34
Bytes: 125
Never mind, since it is called from avc_denied() with AVC_CALLBACK_GRANT always and the cmd and flags provided by the caller.

1033
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_7fe68759
Bytes: 36
od_local.allowed uninitialized here?

1037
Mon Mar 23 18:54:18 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_6de9d180
Bytes: 229
Could take everything from od_local.allowed = &allowed; to here into a noinline helper function and thereby shrink the common case code path and stack.  Case where security_compute_operation() has to be called is a slow(er) path.

1037
Tue Mar 24 20:28:18 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 46d7b47e_6de9d180
UUID: 23eb9264_4a12a790
Bytes: 96
It's required for both the fast and slow path - avc_copy_operation_decision copies into od_local

File: security/selinux/include/avc.h

145
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_ade10918
Bytes: 51
Seems to be used in the opposite sense in the code.

146
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_119e6c68
Bytes: 7
Unused.

File: security/selinux/include/security.h

108
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_b193185c
Bytes: 86
More complex than needed since the expression itself will evaluate to 1 or 0 directly.

108
Mon Mar 23 18:35:11 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66a67829_b193185c
UUID: 66a67829_11c2ecb1
Bytes: 35
(1 & (perms[x >> 5] >> (x & 0x1f)))

File: security/selinux/ss/avtab.c

496
Tue Mar 24 17:31:41 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a3f6a249_00fc88b2
Bytes: 489
I rely on non-unique entries in the avtab to allow different operation types for a source/target/class/specified set. This would require changing to avtab_insert_nonunique for (specified & AVTAB_OPNUM). Will allowing non-unique key entries in the avtab break something? The conditional table allows it, and when searching the avtab for entries, the context_struct_compute_av accounts for it using avtab_search_node_next. Can I get your thoughts in this? libsepol requires a similar change.

496
Tue Mar 24 18:10:10 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a3f6a249_00fc88b2
UUID: a68a309d_26a25cef
Bytes: 658
That seems sane.  Originally context_struct_compute_av() only did a single avtab_search() call since originally all attributes were expanded by checkpolicy and all allow/auditallow/dontaudit rules on the same (source type, target type, target class) were merged to a single entry.  Then when I changed it to preserve policy in attribute form when simple, we switched to avtab_search_node/next.  Conditional policy always required search_node/next since there could be multiple entries for different conditional branches on the same key/specified.  Still need to maintain uniqueness for type transition/change/member rules as otherwise we'd have an ambiguity.

496
Tue Mar 24 18:51:25 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a68a309d_26a25cef
UUID: a3f6a249_e6dad4ea
Bytes: 155
Ok great. Libsepol will continue to consolidate entries as appropriate, but will no longer enforce the uniqueness of source/target/class/specified entries.

File: security/selinux/ss/services.c

635
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_911edc62
Bytes: 91
Only if ops->len == 0, right?  Can be taken under the same conditional as the memset above.

937
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_4d04cd42
Bytes: 85
For AVTAB_OPTYPE, where do we check that od->type is set in node->datum.u.ops->perms?

960
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 260c80ed_ff557756
Bytes: 184
So for any AVTAB_OPTYPE entry that matches on the other key fields, we unconditionally set all bits in op_perms->perms?  How do we know that this entry was for that ioctl command type?

960
Tue Mar 24 20:28:18 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 260c80ed_ff557756
UUID: c3fb9632_07c49cbd
Bytes: 728
AVTAB_OPTYPE is a way of selecting ioctl types where all the numbers are allowed. I added this to handle policy that looks like:
source target:class ~{ 0x8900 0x8911 0x8927-0x8930 0x8940 } 

Here all commands outside the 0x89 type are allowed. Rather than an avtab entry for each type, they can be combined into one entry - AVTAB_OPTYPE. If ioctl 0x8B1B was called on the above source/target/class grouping, it would hit the AVTAB_OPTYPE statement, see that all numbers are allowed within 0x8B and set all numbers to allowed (within that type). If on the other hand 0x8927 was called, the AVTAB_OPTYPE test would evaluate to 0, the AVTAB_OPNUM would find the matching type=0x89 statement and set the permissions specified there.

962
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66a67829_510e3435
Bytes: 10
ARRAY_SIZE

963
Mon Mar 23 16:53:29 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 46d7b47e_ed12e18d
Bytes: 26
May be uninitialized here.

