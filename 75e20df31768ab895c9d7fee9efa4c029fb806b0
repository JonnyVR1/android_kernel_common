Revision: 75e20df31768ab895c9d7fee9efa4c029fb806b0
Patch-set: 5
File: drivers/misc/iface_stat.c

77
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+t4=
Bytes: 79
this is not a type, but a structure, please rename to "create_stat_work_struct"

77
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+t4=
UUID: AAAA/H//+rg=
Bytes: 4
Done

234
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+t0=
Bytes: 90
do not typecast to void *, it is superfluous. This applies to everywhere else in the file.

234
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+t0=
UUID: AAAA/H//+rc=
Bytes: 4
Done

420
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+t8=
Bytes: 60
you should use container_of to get to your container struct.

420
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+t8=
UUID: AAAA/H//+qY=
Bytes: 4
Done

429
Thu Mar 10 23:33:20 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+uM=
Bytes: 425
if i understand this correctly, in steady state, for every packet on any interface, you intend to do 2 list walks one of which is doing strcmp and the other looking for uids?!

For at least the uids, you should look into a moving it to an rb_tree.

Also, you have also now added a point of contention for every packet since they all have to take the iface_list_lock before being dispatched to update the right stat structure.

429
Thu Mar 10 23:44:17 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+uM=
UUID: AAAA/H//+uE=
Bytes: 738
Yes, there are currently two list walks (although the interface list should never really exceed  members - cellular, WiFi, Ethernet/bluetooth). In this version, I chose to replicate the strategy of uid_stats which also does a list walk on uids (iface_stats will replace uid_stats in the near future). I could move from the list to rb_tree in pass 2 or this version if you sa so.


About the iface_list_lock, it does add a point of contention for every packet, but I tried hard to move it to a point where its not done before the packet is dispatched, but after. I am updating stats just before kfree(sk_buff) is called for any outgoing/incoming packet - knowing that a kfree is done outside the critical path and as a low priority action.

490
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+tw=
Bytes: 90
instead of typecasting to work_struct, just pass &create_work->create_work to be explicit.

490
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+tw=
UUID: AAAA/H//+q0=
Bytes: 4
Done

496
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+ts=
Bytes: 77
same as above, do not typecast here, but instead do &create_work->create_work

496
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+ts=
UUID: AAAA/H//+q4=
Bytes: 4
Done

File: net/ipv4/ip_output.c

211
Fri Mar 11 00:14:07 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/H//+to=
Bytes: 567
You should not do the test for protocol here, but rather do it inside your stat function. Also, you should just pass the whole skb into your stat update function and pull out all the relevant info there. So, your interface should probably just look like:
int if_uid_update_tx(struct sk_buff *skb);

This will let you control how to dispatch inside your function based on the protocol, pull out exactly what you need from skb->sk (uid), get the inferface info and packet len, etc. This will also mean that your change to ip_output.c is minimal and is easy to maintain.

211
Fri Mar 11 00:23:29 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+to=
UUID: AAAA/H//+tg=
Bytes: 382
In that case the interface would have to be different for  if_uid_update_tx and  if_uid_update_rx, as I cannot pass struct sk_buff on the receive side, as on the receive path, skb_pull(ip_header) has already been invoked and I will never know the length of the incoming ip_header. 

For the sake of consistency of interface on outgoing/incoming path, I chose to do the parsing here.

211
Fri Mar 11 00:26:15 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+tg=
UUID: AAAA/H//+tY=
Bytes: 49
so how about if_uid_stat_update_(t|r)x(skb, len)?

211
Fri Mar 11 00:31:36 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+tY=
UUID: AAAA/H//+tQ=
Bytes: 146
That won't work either. In tcp_ipv4.c skb->dev = NULL; has been called before I update, which makes determining the incoming interface impossible.

211
Fri Mar 11 18:40:27 2011 +0000
Author: ashishsharma <1005412@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+tQ=
UUID: AAAA/H//+ko=
Bytes: 343
There is another reason why this interface makes more sense instead of passing the entire packet. There are services like mediaserver, download-manager, sync, backup manager - that act on behalf of other applications. So they could use this interface to correctly attribute the transfered bytes to the applications that requested the transfer.

211
Fri Mar 11 19:15:41 2011 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: AAAA/H//+ko=
UUID: AAAA/H//+kM=
Bytes: 607
well no, they can't use this interface since those are userspace processes. You'll need to expose this interface to userspace first (we'll have to be very careful when designing that interface). And when the time comes for you to need to do that, i'm sure your interface will change slightly anyway, because they always do (which is ok).

In any case, I now understand the constraints from tcp_ipv4 etc. However, I still don't like doing the if (TCP) here in it_output. I would prefer that you add 'protocol' as an argument to your function, and have your internals do the right thing based on the protocol.

