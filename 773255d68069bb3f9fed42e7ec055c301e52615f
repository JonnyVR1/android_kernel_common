Revision: 773255d68069bb3f9fed42e7ec055c301e52615f
Patch-set: 1
File: drivers/staging/android/Kconfig

23
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_fd6547f2
Bytes: 1229
I see this config working in a different way. 

1) if 32bit kernel (e.g. ARCH=arm) - use the old interface - where binder_uintptr_t is void * - __u32. Using the 64bit interface where binder_uintptr_t is __u64 is not permitted since it will have a "depends on 64BIT" field.  I am not sure that we want to pass __u64 on systems that do not make use of > 32bit. Also I am not sure it is safe in all cases! As long as your app uses the binder interface at the API level it is suppose to do there should be no issues with 32bit apps running on 64bit systems and 32bit systems since the binder ABI is abstracted away.

2) if 64bit kernel (e.g. ARCH=arm64)- use the 64bit interface ANDROID_BINDER_IPC_64BIT. In this we typedef binder_uintptr_t to __u64 and direct the binder_fops.compat_ioctl to binder_ioctl. Here both 32/64bit APPs will use the 64bit binder interface that uses __u64 for binder_uintptr_t and that allows the apps to coexist / communicate.

Is there a particular reason for using binder_uintptr_t as __u64 on pure 32bit systems (32bit kernel/ 32bit userspace) that I am missing and you would like to cover with this change ?

Please note that with this patch the default for 32bit kernels would be the 64bit interface.

23
Thu Jan 30 03:47:58 2014 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12a87aa1_fd6547f2
UUID: f2b4c6fd_e3ec8176
Bytes: 95
The plan is to remove support for the 32 bit interface and use the 64 bit interface everywhere.

23
Thu Jan 30 03:59:00 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f2b4c6fd_e3ec8176
UUID: f2b4c6fd_c3bf4541
Bytes: 334
We didn't like the idea of the 32-bit version libbinder being compiled differently for a 32-bit kernel vs. a 64-bit kernel.  This should only exist for a relatively short transition period, we figured we should switch the whole binder api to one that is 64-bit safe now and then later get rid of all the compatibility code completely.

26
Wed Jan 29 02:27:51 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12731a25_851c8282
Bytes: 55
mention that this will break the new Android user-space

File: drivers/staging/android/binder.c

525
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2b1820e_5b77a3a7
Bytes: 34
why not (struct binder_buffer *) ?

3537
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 929c6a85_61a516c4
Bytes: 173
Why do we need this? unlocked_ioctl won't be defined for 64bit kernels that are using the 32bit interface which is already covered by:

BINDER_IPC_32BIT
   depends on !64BIT

3537
Thu Jan 30 03:47:58 2014 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 929c6a85_61a516c4
UUID: 92870a29_52b085c2
Bytes: 92
We don't need it. I commented out that line to test the 32 bit interface on a 64 bit kernel.

3540
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_7d7a5793
Bytes: 141
The common idiom is to have .compat_ioctl surrounded by a CONFIG_COMPAT clause. I am not sure we want to expose this for 32bit architectures.

3540
Thu Jan 30 03:47:58 2014 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12a87aa1_7d7a5793
UUID: 92870a29_f2c89942
Bytes: 117
Even when the compat_ioctl points to the same handler? I see both used in other drivers, and the field always exists.

3540
Thu Jan 30 03:59:00 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92870a29_f2c89942
UUID: f2b4c6fd_63af510e
Bytes: 148
compat_ioctl can never get called when CONFIG_COMPAT is not set, and CONFIG_COMPAT doesn't exist for 32-bit kernels. There is no need for an #ifdef.

File: drivers/staging/android/uapi/binder.h

23
Thu Jan 30 03:59:00 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92870a29_d2e2b5b4
Bytes: 94
you could move this block to ../binder.h so the uapi file doesn't reference any CONFIG options

24
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_1d7113b1
Bytes: 234
Why do we need this extra flag ? Is it because of the scripts that generate the bionic headers? We can add CONFIG_ANDROID_BINDER_IPC_32BIT to the white list and such the scripts won't remove the CONFIG_ANDROID_BINDER_IPC_32BIT blocks.

24
Thu Jan 30 03:47:58 2014 +0000
Author: Arve Hjønnevåg <1000205@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12a87aa1_1d7113b1
UUID: 52811216_1080c5dd
Bytes: 43
I did not see a white list. Does one exist?

24
Thu Jan 30 03:59:00 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 52811216_1080c5dd
UUID: 92870a29_f2dfb9f1
Bytes: 172
I like this better, it makes it clear that this is a conditional that applies to both userspace and the kernel.  Setting a CONFIG_* option in userspace seems strange to me.

