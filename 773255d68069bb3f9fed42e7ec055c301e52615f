Revision: 773255d68069bb3f9fed42e7ec055c301e52615f
Patch-set: 1
File: drivers/staging/android/Kconfig

23
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_fd6547f2
Bytes: 1229
I see this config working in a different way. 

1) if 32bit kernel (e.g. ARCH=arm) - use the old interface - where binder_uintptr_t is void * - __u32. Using the 64bit interface where binder_uintptr_t is __u64 is not permitted since it will have a "depends on 64BIT" field.  I am not sure that we want to pass __u64 on systems that do not make use of > 32bit. Also I am not sure it is safe in all cases! As long as your app uses the binder interface at the API level it is suppose to do there should be no issues with 32bit apps running on 64bit systems and 32bit systems since the binder ABI is abstracted away.

2) if 64bit kernel (e.g. ARCH=arm64)- use the 64bit interface ANDROID_BINDER_IPC_64BIT. In this we typedef binder_uintptr_t to __u64 and direct the binder_fops.compat_ioctl to binder_ioctl. Here both 32/64bit APPs will use the 64bit binder interface that uses __u64 for binder_uintptr_t and that allows the apps to coexist / communicate.

Is there a particular reason for using binder_uintptr_t as __u64 on pure 32bit systems (32bit kernel/ 32bit userspace) that I am missing and you would like to cover with this change ?

Please note that with this patch the default for 32bit kernels would be the 64bit interface.

26
Wed Jan 29 02:27:51 2014 +0000
Author: Colin Cross <1002751@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12731a25_851c8282
Bytes: 55
mention that this will break the new Android user-space

File: drivers/staging/android/binder.c

525
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2b1820e_5b77a3a7
Bytes: 34
why not (struct binder_buffer *) ?

3537
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 929c6a85_61a516c4
Bytes: 173
Why do we need this? unlocked_ioctl won't be defined for 64bit kernels that are using the 32bit interface which is already covered by:

BINDER_IPC_32BIT
   depends on !64BIT

3540
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_7d7a5793
Bytes: 141
The common idiom is to have .compat_ioctl surrounded by a CONFIG_COMPAT clause. I am not sure we want to expose this for 32bit architectures.

File: drivers/staging/android/uapi/binder.h

24
Wed Jan 29 11:30:47 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12a87aa1_1d7113b1
Bytes: 234
Why do we need this extra flag ? Is it because of the scripts that generate the bionic headers? We can add CONFIG_ANDROID_BINDER_IPC_32BIT to the white list and such the scripts won't remove the CONFIG_ANDROID_BINDER_IPC_32BIT blocks.

