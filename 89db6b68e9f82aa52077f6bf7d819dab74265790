Revision: 89db6b68e9f82aa52077f6bf7d819dab74265790
Patch-set: 1
File: drivers/cpufreq/cpufreq_interactive.c

0
Fri Apr 10 18:20:16 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2368f29d_882c1f40
Bytes: 202
Are all these changes same except commit text?
https://android-review.googlesource.com/#/c/146291/
https://android-review.googlesource.com/#/c/146292/
https://android-review.googlesource.com/#/c/146310/

499:5-499:9
Fri Apr 10 18:20:16 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4365e6c2_5d164f00
Bytes: 1053
I think this has to be target_freq or we could keep CPU at high freq indefinitely.

Imagining two CPUs managed by one policy. CPU A is fully busy and its target_freq is policy->max, and thus keeping cluster frequency at policy->max. CPU B is idling at non-min freq with both timer scheduled. (They could be scheduled before CPU A ramped up to policy->max.)

CPU B wakes up at beginning of the window where slack_timer would fire. Its regulaor timer drops its target_freq to policy->min because load is 0. With this change, it won't schedule regular timer, but slack timer is left unchanged.  CPU B does quite a lot of work before going to sleep again in same window. CPU B's slack time fires at end of this window, sees the busy time CPU B consumed in that window, and ramps up its target_freq to some middle frequency. CPU B's timers are again not scheduled because CPU A is keeping policy->cur at policy->max. If CPU B goes to long idle afterwards, its target_freq will keep policy frequency high forever even if CPU A ramps down to policy->min later.

