Revision: 89db6b68e9f82aa52077f6bf7d819dab74265790
Patch-set: 1
File: drivers/cpufreq/cpufreq_interactive.c

0
Fri Apr 10 18:20:16 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2368f29d_882c1f40
Bytes: 202
Are all these changes same except commit text?
https://android-review.googlesource.com/#/c/146291/
https://android-review.googlesource.com/#/c/146292/
https://android-review.googlesource.com/#/c/146310/

424
Thu Apr 16 15:36:58 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 907ac6a8_6c155173
Bytes: 349
I think the changes above here look fine -- they mean we are calculating the new_freq based on the current frequency instead of our un-attained target that might no longer be appropriate.

The changes below here don't seem right though since they are deciding whether we need to set target_freq to the new_freq and whether or not to rearm the timer.

433
Thu Apr 16 15:36:58 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30d59acf_3a0b20ad
Bytes: 190
if new_freq > cur but new_freq < target, we leave target alone on this pass even though it is now stale. We don't want to skip to "rearm" since that skips setting the new target at line 487.

433
Thu Apr 16 17:41:08 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30d59acf_3a0b20ad
UUID: 10597645_43260ee6
Bytes: 1075
"new_freq > cur but new_freq < target" means target > cur, which shouldn't really happen as long as we are always waking up speedchange task correctly and setting frequency properly, right?

Even if it happens, I could argue that policy->cur should have been target_freq and not letting target_freq to drop is the right thing. The CPU never gets a chance to run at target_freq and apparently current frequency is still not enough.

More importantly though we probably want to wake up speedchange_task if target > cur. On the other hand new_freq could be same as target_freq at any time. So if we really want to handle the error case where speedchange task could fail to change frequency, 55c5ba1 alone is not enough. We need to diligently check before every return whether we want to wake it up or not. Worse yet, if we cancel timer at fmax, we might never have such a chance to remedy the situation in timer function, and speedchange_task needs to check return value of __cpufreq_driver_target() and somehow recover. I think that's a separate (and not trivial) issue though.

475
Thu Apr 16 15:36:58 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30d59acf_5a4144f7
Bytes: 235
This doesn't seem right either. This conditional is deciding whether our target_freq is staying the same and if so skips setting target_freq to the new value at line 487. If we've calculated a new frequency, we want to set target_freq.

475
Thu Apr 16 17:41:08 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30d59acf_5a4144f7
UUID: 10597645_23231ad5
Bytes: 51
Agree. Missed this one. It needs to be target_freq.

499:5-499:9
Fri Apr 10 18:20:16 2015 +0000
Author: Junjie Wu <1070083@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4365e6c2_5d164f00
Bytes: 1053
I think this has to be target_freq or we could keep CPU at high freq indefinitely.

Imagining two CPUs managed by one policy. CPU A is fully busy and its target_freq is policy->max, and thus keeping cluster frequency at policy->max. CPU B is idling at non-min freq with both timer scheduled. (They could be scheduled before CPU A ramped up to policy->max.)

CPU B wakes up at beginning of the window where slack_timer would fire. Its regulaor timer drops its target_freq to policy->min because load is 0. With this change, it won't schedule regular timer, but slack timer is left unchanged.  CPU B does quite a lot of work before going to sleep again in same window. CPU B's slack time fires at end of this window, sees the busy time CPU B consumed in that window, and ramps up its target_freq to some middle frequency. CPU B's timers are again not scheduled because CPU A is keeping policy->cur at policy->max. If CPU B goes to long idle afterwards, its target_freq will keep policy frequency high forever even if CPU A ramps down to policy->min later.

499:5-499:9
Thu Apr 16 15:36:58 2015 +0000
Author: Todd Kjos <1069543@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4365e6c2_5d164f00
UUID: 907ac6a8_6c679123
Bytes: 239
I agree with Junjie that line 499 should use target_freq -- remember, this is the newly calculated target_freq (line 487), and our check for rearm should be based on the expectations of where we think we are going to be during the interval

