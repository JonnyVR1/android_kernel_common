Revision: 6723654efe7d6d1c574f7d09131c9c0a4d0c9cbc
Patch-set: 1
File: net/ipv4/tcp.c

3521:1-3521:11
Wed Feb 17 18:51:29 2016 +0000
Author: Dmitry Shmidt <1000414@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5d8fa87c_0e9e9e90
Bytes: 27
Need the check if rt6 is Ok

3521:1-3521:11
Thu Feb 18 00:53:52 2016 +0000
Author: Liping Zhang <1086323@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5d8fa87c_0e9e9e90
UUID: fd705c1a_9ea04d6b
Bytes: 257
Actually ip[6]_rt_put can handle NULL pointer itself, and this was explained on its code comments: "dst_release() accepts a NULL parameter. We rely on dst being first structure in struct rt6_info". So even if rt6 is NULL, call ip6_rt_put is still safe here.

3521:1-3521:11
Thu Feb 18 01:16:18 2016 +0000
Author: JP Abgrall <1005480@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fd705c1a_9ea04d6b
UUID: fd993cfa_9fde17f8
Bytes: 88
dst_release(), yes.
But it is not a dst that is passed in but rt which must not be null.

3521:1-3521:11
Thu Feb 18 01:43:01 2016 +0000
Author: Liping Zhang <1086323@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fd993cfa_9fde17f8
UUID: 7d170cd9_18e905fd
Bytes: 296
This statement "&rt->dst" will not dereference the rt pointer actually, it is equal to "(char *) rt + offsetof(struct rt6_info, dst)", and there's a BUILD_BUG_ON to ensure that offsetof(struct rt6_info, dst) is always 0. If rt6 is NULL, &rt->dst is also NULL, so ip[6]_rt_put(NULL); call is safe.

