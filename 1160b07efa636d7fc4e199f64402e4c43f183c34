Revision: 1160b07efa636d7fc4e199f64402e4c43f183c34
Patch-set: 1
File: drivers/net/wireless/bcmdhd/wl_cfg80211.c

11034:3-11034:21
Wed Sep 09 17:09:51 2015 +0000
Author: Dmitry Shmidt <1000414@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24c9e69c_67c07a65
Bytes: 135
This doesn't look right - we take 1 wakelock count per semaphore UP and one down - taking one down in internal loop doesn't seem right.

11034:3-11034:21
Wed Sep 09 17:48:37 2015 +0000
Author: Insun Song <1072843@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 24c9e69c_67c07a65
UUID: 64cf5e9f_249efc22
Bytes: 399
@Dmitry Shmidt. 
We set wakelock for every enqueued event. So I think it's right to set unlock for every deque event and not counting on semaphore.  Previous mechanism was setting unlock one time after all deque multiple event processing done.

What we found that sometimes mismatch count was seen between wl_wakup_event(wake lock) and wl_event_handler(wake unlock). Then leave wake lock count high.

11034:3-11034:21
Wed Sep 09 17:54:38 2015 +0000
Author: Dmitry Shmidt <1000414@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_249efc22
UUID: 24c9e69c_67719ad6
Bytes: 63
Then this is a wrong design - you need to get rid of loop then.

11034:3-11034:21
Wed Sep 09 21:52:07 2015 +0000
Author: Dmitry Shmidt <1000414@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 24c9e69c_67719ad6
UUID: 24c9e69c_0dfd65a8
Bytes: 125
If we are calling wl_wakeup_event() per one event insertion in the queue - then it makes sense but then why we need the loop?

11034:3-11034:21
Thu Sep 10 23:10:55 2015 +0000
Author: Insun Song <1072843@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 24c9e69c_0dfd65a8
UUID: a4bdd6e7_d9cf2690
Bytes: 61
@Dmitry Shmidt. 
I will get back to you soon after reviewing.

