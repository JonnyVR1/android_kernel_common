Revision: 0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6
Patch-set: 1
File: include/linux/lsm_audit.h

72
Thu Jan 15 15:16:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6b2473a4_99e25f2d
Bytes: 211
Could make this a struct containing both the struct path (or dentry or whatever) and the unsigned int ioctlcmd and then display them both together on denials.  Also, this file diff belongs with the other change.

File: security/selinux/hooks.c

92
Thu Jan 15 15:16:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb106340_dd6c3f75
Bytes: 181
I'd put this file diff with the change that creates this header file. More generally, you only need at most two changes - one for the general LSM infrastructure and one for SELinux.

92
Thu Jan 15 21:44:59 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb106340_dd6c3f75
UUID: 0b49377c_8323fe11
Bytes: 103
Rgr. So two patches, a small (~20 lines) lsm_audit patch, and a much larger (~350 lines) selinux patch.

3137
Thu Jan 15 15:16:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6b2473a4_39eb4b08
Bytes: 22
Use cred_sid() helper.

3142
Thu Jan 15 15:16:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb106340_9d76c73f
Bytes: 90
Use a struct so you can pass both the path and the cmd for inclusion in the audit message.

3143:35-3143:48
Thu Jan 15 02:10:54 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb106340_faa0297a
Bytes: 411
a file descriptor could represent a plain file, character file, unix domain socket, etc... All of these can have ioctls performed on them.

It feels wrong to use SECLASS_FILE here, since it could also be a SECCLASS_CHR_FILE or SECCLASS_TCP_SOCKET depending on how it's called.

Stephen: are there any functions available which take a file descriptor, and return the SECCLASS appropriate to that file descriptor?

3143:35-3143:48
Thu Jan 15 03:10:52 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb106340_faa0297a
UUID: 2b051bfe_65f0fc21
Bytes: 188
Good catch! I believe that could be accessed by:

struct inode_security_struct *isec;
struct inode *inode = file_inode(file);
isec = inode->i_security;
isec->sclass

I will update tomorrow

3144
Thu Jan 15 15:16:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6b2473a4_19f08fee
Bytes: 336
This is problematic; you are reusing an existing class/permission combination for a completely different purpose and different target context.  You really need a new permission for this check.  And it has to be added to COMMON_FILE_SOCK_PERMS in security/selinux/include/classmap.h so that it is defined for all file and socket classes.

3144
Thu Jan 15 23:25:03 2015 +0000
Author: Stephen Smalley <1010099@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b2473a4_19f08fee
UUID: 2ba19b5e_1ce5f562
Bytes: 1688
Actually, I think this check still won't be right even with its own permission.  IIUC, you want to be able to express in policy goals like "untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device".  Which requires that your check take into account the task/cred SID, the device node SID (i.e. the inode SID), and the ioctl command.  Normally we would think of the ioctl command as corresponding to a permission, but of course we can't support such a mapping due to the limited permission space and vast ioctl space.  By trying to map the ioctl command to a target SID, you are losing the device node SID from the equation.  Two independent checks, one on the device node SID and one on the ioctl command SID, doesn't seem sufficient, e.g. if you want to allow ioctl command N on device node D1 and ioctl command M on device node D2, you'll have to allow ioctl to D1 and D2 and ioctl (or new permission) to SID(N) and SID(M).  Which will also allow ioctl M on D1 and N on D2.  All that to say that I would not try to model this as a regular permission check.  Instead, just introduce a new structure within the policydb and a new function exported by the security server that allows checking based on source SID (the task/cred SID), target SID (the inode SID for the device file), maybe the target class (if we think we'll use the same target SID on both block and character devices and need to distinguish?), and the ioctl command.  Internally we'd have something like the avtab to look up by source type, target type, and target class, and then check against your whitelist of ioctl commands.  More work, and more of a change to libsepol/checkpolicy, but seems more suited.

3144
Fri Jan 16 00:20:20 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2ba19b5e_1ce5f562
UUID: 2bcfdb48_cca10f36
Bytes: 670
> IUC, you want to be able to express in policy goals like "untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device".

That's the ideal state, but I'd also be OK with being able to express a policy like:

  untrusted_apps can only invoke ioctls A, B-D, and Q on a character device

which isn't as good as what you proposed above...

If we're trying to express the ideal state, what would that look like from a policy perspective? More concretely, I'm having a tough time envisioning what an "allow" rule would look like under such a scenario.

Like this?

  allow untrusted_app gpu_device:chr_file ioctlA;
  allow untrusted_app gpu_device:chr_file ioctlBD;

3144
Fri Jan 16 00:39:40 2015 +0000
Author: Stephen Smalley <1010099@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2bcfdb48_cca10f36
UUID: 6b971303_418cf418
Bytes: 466
I'd think you could specify a list of ioctl commands and/or ranges, ala allow untrusted_app gpu_device:chr_file { A B-D Q };

Doing it as two checks might be ok if the ioctl command value space is largely non-overlapping among different drivers, or has the same semantic meaning across them for the values that are common, but I'm not sure we can rely on that behavior.

Might be helpful to work up an actual pseudo policy for a set of drivers in Android and assess.

3144
Fri Jan 16 01:29:18 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b971303_418cf418
UUID: 6bc55323_f4f13072
Bytes: 593
I'm glad you brought this up.

It's important to note that this is the same issue with netport and netnode. They deal with socket TSID and port/addr TSID separately.

I need to think about this more, but I will be considering two options:

1) how to implement your example statement using the current two-check code and have the policy compiler solve the command space problem.

2) how to use a single check. Adding a new statement to the policydb seems trivial, it's the avc lookup that is the difficulty. Currently it only uses the SSID, TSID and class for lookups. How would we expand this?

3144
Fri Jan 16 14:59:52 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6bc55323_f4f13072
UUID: 6b971303_e458aecb
Bytes: 901
The difference with netport/netnode is that ports and nodes are objects and thus it makes sense to label them and apply permission checks to them.  ioctl commands aren't objects per se but rather operations and thus map more logically to permissions.  I would think we could extend the AVC in much the same way as the avtab (or provide a separate cache), as they will continue to be keyed on SSID, TSID, and class but the struct av_decision returned by the security server could be extended to support returning an array of ioctl commands/operations and the AVC could simply check for a match.  If we can rely on the standard encoding of ioctl numbers (Documentation/ioctl/ioctl-decoding.txt and ioctl-number.txt), we could perhaps only consider the low half of the ioctl command value (driver + function) or even just the low byte (function) and thus represent the ioctl command array more compactly.

3144
Fri Jan 16 22:10:56 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b971303_e458aecb
UUID: 0ba5b782_2696b8d9
Bytes: 1538
"the struct av_decision returned by the security server could be extended to support returning an array of ioctl commands/operations and the AVC could simply check for a match."

That seems reasonable.

I don't think we can assume that drivers conform to the ioctl-decoding document, I'm not sure it's even possible with only 256 values that are "supposedly unique to each driver". But despite that I would expect the array (assuming it represents ranges) would be quite short for each SSID/TSID/class set and therefore reasonable to search through.  

Or, alternatively consider:

Use the 2-check system show here and the existing AVC structure. Use policy compiler to resolve ioctl range overlap. 

For example
allow app1 gpu_device:chr_file ioctl { 12 }; 
allow app2 gpu_device:chr_file ioctl { 10-15 };
allow app2 gpu_device:chr_file ioctl { 5-25 };
The compiler would expand to
allow {app1 app2 app3 } gpu_device:chr_file ioctl { 12 } 

allow { app2 app3 } gpu_device:chr_file ioctl { 10-11 };
allow { app2 app3 } gpu_device:chr_file ioctl { 13-15 };

allow app3 gpu_device:chr_file ioctl { 5-9 };
allow app3 gpu_device:chr_file ioctl { 16-25 };

Benefits:
Uses existing AVC as-is
We can load the command -> tsid policy mapping presorted which would allow a faster binary search on the initial lookup and the command cache for faster subsequent lookups.
In general, there shouldnâ€™t be a lot of overlapping command ranges. Drivers tend to have sequential ranges, and we only need to account for the occasional non-conforming driver.

3144
Tue Jan 20 17:45:57 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0ba5b782_2696b8d9
UUID: 6b6c7315_19c72fda
Bytes: 4
Done

