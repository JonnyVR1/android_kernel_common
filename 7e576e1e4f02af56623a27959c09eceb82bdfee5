Revision: 7e576e1e4f02af56623a27959c09eceb82bdfee5
Patch-set: 3
File: drivers/md/dm-uevent.c

207
Thu Jun 20 15:35:41 2013 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a96e156_6c73fbab
Bytes: 849
Hrm. This makes a lot of sense given that multipath leaks into this file.  For my taste, it'd be ideal if a new helper was exposed that let the targets add the env vars they wanted then sent it.

As is, this seems sane to try upstream and see what they say.  I wouldn't be surprised if they decide that 1 is okay but 2's a crowd and ask for a generalized helper.  If not, then you're golden :)

From the verity perspective, I'm wondering if there's a good way to have this also do kernel notification rather than relying on udev to hear and respond. I'm guessing the worst case is lots of -EIOs, so maybe it's sane to delegate it userland for the error case.  For CrOS, we used a kernel notifier, but it got stripped out of the rewrite that landed upstream.  If this goes upstream, then we'll migrate over to uevent and drop out out of tree handler.

207
Thu Jun 20 16:57:02 2013 +0000
Author: Dima Zavin <1000413@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a96e156_6c73fbab
UUID: 0ad591ff_6f991d30
Bytes: 773
I had the same initial reaction that we should not pollute dm-uevent.c with a verity-specific sender, put that stuff into dm-verity.c, and make some sort of helper here. But, like you, I let it slide because it's no worse than the mpath stuff already here and this change is pretty small :)

Re kernel notifications, I'm not sure what you can do from the kernel that you couldn't do from userspace. If you really, really  wanted to, you can add a blocking notifier chain (is that what you guys already do?) and have one of the calls do the uevent sending, but that seems like overkill from my perspective. Our preferred handling is to just throw the event to userspace and let it figure out the right thing to do.

What do you guys do in CrOs in the kernel on these events?

207
Thu Jun 20 17:31:02 2013 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0ad591ff_6f991d30
UUID: 8a96e156_2ce4932e
Bytes: 1198
Yeah - I had to go back and edit my response once I saw what mpath did!

For CrOS -- our kernel handler is blazingly dull.  It gets notified via a blocking notifier chain, uses a stored UUID of the kernel partition to find and write one sector to the front of the partition (DMVERROR) then reboots.  This causes verification to fail and sends the user to the other kernel partition. (If that one is invalid, they go to recovery mode).

Our handler: http://git.chromium.org/gitweb/?p=chromiumos/third_party/kernel.git;a=blob;f=drivers/md/dm-verity-chromeos.c;h=501be96aa9d273023a2b022604b2190751241e8f;hb=refs/heads/chromeos-3.4

A view into the 3.4 code:
  http://git.chromium.org/gitweb/?p=chromiumos/third_party/kernel.git;a=blob;f=drivers/md/dm-verity.c;h=a4f186d669183e387f2e787fe36353b9366da94c;hb=refs/heads/chromeos-3.4#l116

(We're in the process of a 3.8 roll)

I suspect that as long as -EIO is returned for every request, notifying userspace will be better I suspect.  It does make it easier for a root-level attacker to keep the system from rebooting, but I wouldn't expect the first move to be modifying the root partition while verity is actively running in enforcement mode either :)

