Revision: 1f1305e913be30439282e742bf1fa6cc61995e85
Patch-set: 5
File: drivers/gpu/ion/ion.c

35
Fri May 20 06:32:24 2011 +0000
Author: Venkata Dumpa <1004936@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABAH///+Q=
Bytes: 17
can it be static?

61
Fri May 20 06:32:24 2011 +0000
Author: Venkata Dumpa <1004936@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABAH///zg=
Bytes: 71
order of member documentation is not as per order of members in struct.

334
Thu Apr 28 08:18:16 2011 +0000
Author: KyongHo Cho <1006275@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///oA=
Bytes: 165
If this function covers IOMMU mappings, this doesn't need to be pointer type but an integral type because CPU is unable to access the device address mapped for IOMMU

460
Fri May 20 06:32:24 2011 +0000
Author: Venkata Dumpa <1004936@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABAn//+5g=
Bytes: 134
Does each client of ion mem manger need to pass a mapper? where does the clients that call this api in kernel supposed to get it from?

498
Thu May 19 06:51:03 2011 +0000
Author: KyongHo Cho <1006275@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABAn///Qo=
Bytes: 145
What if there are more than one request to create an ion_client in the same task's address space? It is likely to be happened in the kernel mode.

516
Thu Apr 28 08:18:16 2011 +0000
Author: KyongHo Cho <1006275@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///oE=
Bytes: 180
I think this is wrong.
because the initial node, '*p' is not the node in kernel_clients.
Thus the new ion_client is linked in user_clients but reordering is done in kernel_clients.

654
Wed Apr 13 15:44:30 2011 +0000
Author: Rob Clark <1006181@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/n//+n4=
Bytes: 293
as mentioned y'day (just capture here for posterity), it would be nice if you let the heap implementation optionally provide a fault handler.. could be useful to track cache cleanness, and also probably other usages in cases where you have a GART/GTT or something that vaguely looks like one..

697
Mon Jul 04 13:57:44 2011 +0000
Author: Mark Underwood <1006840@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABEX//+xA=
Bytes: 52
Why are we getting a kernel address for this buffer?

774
Thu Apr 28 08:18:16 2011 +0000
Author: KyongHo Cho <1006275@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///oQ=
Bytes: 106
Did you intended to let users know kernel virtual address as a handle?
Doesn't it have a security problem?

801
Fri May 20 06:32:24 2011 +0000
Author: Venkata Dumpa <1004936@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABAn///C0=
Bytes: 58
Where would the file created here gets destroyed and when?

988
Thu Apr 28 08:18:16 2011 +0000
Author: KyongHo Cho <1006275@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///oI=
Bytes: 229
I think you assumed that we need just one mapper for user's address space. I think we need more than one mapper for users.
Users may want non-cacheable mapping rather than cacheable mapping.
Otherwise, passing flags seems enough.

File: drivers/gpu/ion/ion_heap.c

31
Mon Jul 04 13:57:44 2011 +0000
Author: Mark Underwood <1006840@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABEX//+xM=
Bytes: 225
Is the intention to stick with switch cases for the different heap types? It would be cleaner if each heap registered a structure of callbacks. This would also allow heaps to come and go which might be required in the future.

File: drivers/gpu/ion/ion_mapper.c

29
Mon Jul 04 13:57:44 2011 +0000
Author: Mark Underwood <1006840@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABEX//+xE=
Bytes: 226
Is the intention to stick with switch cases for the different mappers? It would be cleaner if each mapper registered a structure of callbacks. This would also allow mappers to come and go which might be required in the future.

File: drivers/gpu/ion/ion_priv.h

97
Wed Apr 27 15:00:17 2011 +0000
Author: Lajos Molnar <1006279@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///vY=
Bytes: 41
Do you mean kernel-space virtual address?

File: drivers/gpu/ion/tegra/tegra_ion.c

34
Mon Jul 04 13:57:44 2011 +0000
Author: Mark Underwood <1006840@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAABEX//+xI=
Bytes: 412
I wonder if some of this init could be done at subsystem init time. It would save having the same code duplicated for each system.

I'm also wondering who's job it is to do this init? It's easier for SoC's as you can define a common point to do this, but in the x86 environment it's harder as you might have multiple ION devices (e.g. an “ion” GPU and an “ion” camera driver) which are being hot-plugged.

File: include/linux/ion.h

114
Wed Apr 27 15:00:17 2011 +0000
Author: Lajos Molnar <1006279@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///vU=
Bytes: 47
Same question as below for ion_allocation_data.

132
Wed Apr 27 15:00:17 2011 +0000
Author: Lajos Molnar <1006279@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///vg=
Bytes: 117
Do you mean kernel-space virtual address?  If you really mean physical, return address should be an unsigned integer.

203
Wed Apr 27 15:00:17 2011 +0000
Author: Lajos Molnar <1006279@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///vs=
Bytes: 210
This is fine for a linear (1D) allocation.  Will the same API be used for other (e.g. 2D) allocation for architectures that have 2-dimensional memory layout?  If yes, how will the other dimensions be specified?

204
Wed Apr 27 15:00:17 2011 +0000
Author: Lajos Molnar <1006279@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/3///vQ=
Bytes: 325
If you need to allocate multiple co-aligned buffers, will this be expected to be done in one alloc call?  E.g. on some 2D architectures NV12/NV21/etc buffers need to be coaligned if they are mapped contiguously (as 1 buffer) to user space.  Other option is to require user space to always handle each sub-buffer individually.

206
Wed Apr 13 15:44:30 2011 +0000
Author: Rob Clark <1006181@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: AAAA/n//+nk=
Bytes: 844
fwiw GEM does not try to standardize the allocation ioctl/api..  I think if you do you end up having to rev the API each time a new SoC comes along with something new and crazier.  Instead memory allocation is done by a vendor provided userspace driver (either their xorg driver, or hw specific vaapi/vdpau driver).  So when a buffer object (bo) is allocated for multimedia, maybe some of the options passed down to vendor specific kernel part would be different compared to bo's allocated for graphics pixmaps..  and might differ from gpu to gpu.

Instead the approach is to standardize the API for passing around / manipulating buffers once they are allocated.

I'm not sure if that sort of approach fits in with the Android userspace architecture.. but I guess there is vendor specific OMX implementation, gralloc, etc.  So I guess it might?

