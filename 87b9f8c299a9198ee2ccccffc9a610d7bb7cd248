Revision: 87b9f8c299a9198ee2ccccffc9a610d7bb7cd248
Patch-set: 2
File: init/do_mounts.c

561:9-561:24
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6a6fdc1_b20b7e66
Bytes: 480
This means that the verity_table cannot contain layered dm targets. E.g.
dm-0=dm-bootcache
dm-1=dm-verity

Is there a reason not to leave root= alone (e.g., have the cmdline populate it as root=/dev/dm-0) and add a new commandline flag to pass in anything needed?  If not, it would make sense to have the new root be set by dm_run_setup().


I'd prefer not as a magic root= value is harder to debug than having a known one and an explicit parameter that sets up what it points at.

File: init/do_mounts.h

80:0-80:4
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6b795e1_c2b3d321
Bytes: 40
init __init dm_run_setup(char *rootdev);

84:7-84:11
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_136b576b
Bytes: 176
q: a 'static' defined as __init section is probably meaningless, but it does clearly state to the developers that whatever code it produces could disappear later? Just curious.

File: init/do_mounts_android_verity.c

53:9-53:18
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6f27de4_52879214
Bytes: 218
with this here, why replace root=?

Also, going down this route makes this patch very specialized.  IMO, it'd be better to break it up into a dm="" style patch then add a new table-type for DM for android-style verity.

70:44-70:61
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_bcd369e5
Bytes: 152
this looks like similar code to kernel/module_signing.c.  Is there a chance (later) to share code so this doesn't block the on-flash size of the kernel?

104:30-104:33
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_9cd6add6
Bytes: 133
nit: This would give me less of the heebie jeebies if it didn't rely on type +1 behavior. E.g.,
   desc = (void *)pks + sizeof(*pks);

104:30-104:33
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c81977_9cd6add6
UUID: 76fd65bf_c5a4dae1
Bytes: 376
void * pointer math is defined as illegal in the C specification. You must use u8 *. There can be debate over all styles of pointer math ... :-(

6.2.5-19: The void type comprises an empty set of values; it is an incomplete type that cannot be completed.
Since void is an incomplete type, it is not an object type. Therefore it is not a valid operand to an addition operation.

176:28-176:34
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36bdadca_d6c3a2bd
Bytes: 126
does pr_init_info annotate with the calling func or file? If not, it'd be good to note that this is verity_create_dev waiting.

183:2-183:24
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_54416221
Bytes: 67
why is this code cargoculted from  do_mounts.c:prepare_namespace()?

189:15-189:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56c22158_d7a9de52
Bytes: 19
debugging leftoves?

208:0-208:68
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 968d7947_f4ec10eb
Bytes: 117
Whoa - cool.  Is this safe during early boot? I had assumed you'd  have to just grab the sectors with a bio directly.

325:5-325:16
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6f27de4_12910a4c
Bytes: 526
so if the phone is unlocked, it'll just passthrough? And the kernel parameters are bootloader specific, right?

In this scenario there are two trusted parties:
- signed data on disk
- kernel command line
where the latter has the priority since the disabled bit on disk isn't a signed bit.

Is this the intention?  If so, why does the kernel have to do all the signing and not leave it in one trusted place -- the bootloader/handoff?

If it's because of legacy secure bootloaders, we still expect good signals on locked status?

429:19-429:33
Wed Oct 21 11:37:42 2015 +0000
Author: Sami Tolvanen <1058768@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b988aea5_dff25b98
Bytes: 132
In fs_mgr_setup_verity, we also mark the underlying device as read-only after dm-verity has been set up. Should we do the same here?

429:19-429:33
Wed Oct 21 22:58:45 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b988aea5_dff25b98
UUID: 194a9a42_d8a7c528
Bytes: 451
I think we are doing that as well !!

fs_mgr seems to call into fs_mgr_set_blk_ro which makes a BLKROSET ioctl.. drivers/md/md.c seems to service this by calling into set_disk_ro.

In our kernel module, do_mounts_verity.c directly calls set_disk_ro(line 53). Verity_args.ro argument is hardcoded to 1. So, we always mark this read only as long as we are mounting the blkdevice through dm.

Let me know if this is not suffice or If am missing something

457:0-457:63
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_943aeaac
Bytes: 70
Is there another way to do this without duplicate device waiting, etc?

458:15-458:21
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_900e7a77
Bytes: 67
It's not the rootdev though is it? It's the metadata device, right?

468:23-468:26
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_7c9b913f
Bytes: 133
nit: it'd be nice to pass around the struct being used and not assume global access just from style perspective. (Here and elsewhere)

479:2-479:6
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6a6fdc1_92575a3b
Bytes: 108
any reason to have an else here and not just:
    if (verity...)
      goto err_vrity_table;
    goto err;
?

502:44-502:47
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36f76de3_63b4020b
Bytes: 227
this string should go into the init section ;-}

can be defined locally within this block:

while (i < VERITY_TABLE_ARGS) {
    static const char delim[] __initconst = " ";

    verity_table_args[i] = strsep(&table_ptr, delim);

526:16-526:28
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56c22158_576f8eba
Bytes: 87
would be good to check that this doesn't wrap (though the result will be checked by dm)

547:16-547:23
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_b00b7666
Bytes: 62
out of curiosity, why is vmalloc() being used everywhere here?

547:16-547:23
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76880537_b00b7666
UUID: d6ae1193_989b0a3f
Bytes: 366
Does not draw from the precious physically contiguous pool of pages from the slab allocator or dma resources. The main advantages of using vmalloc show up when accessing more than a page size though ...

Also, vmalloc does not incite a kernel panic when starved for memory (but typically you have a fallback plan, like using a smaller buffer, or less functionality).

File: init/do_mounts_android_verity.h

1:8-1:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_f0ec1eeb
Bytes: 12
boilerplate?

56:28-56:29
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56e941ce_066ddbed
Bytes: 225
Beware of holes in structures? __packed to be sure?

metadata_start 'starts' on a u32 boundary as it stands, can the structure be refactored so that metadata_start and verity_table pointer are guaranteed on a 64-bit boundary?

78:0-78:14
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6d8bd3b_ded9f455
Bytes: 28
starts on a 32-bit boundary.

File: init/do_mounts_verity.h

1:19-1:31
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 169a6978_d5d0eeda
Bytes: 11
boilerplate

7:8-7:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_b437eec5
Bytes: 31
is this standard anywhere else?

45:5-45:17
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_bc9c4936
Bytes: 196
If you only ever setup one target, you don't need a lot of the work here.  Of course, if you only setup one target, then this patch set will definitely not be compatible with usage in chrome os :/

