Revision: 87b9f8c299a9198ee2ccccffc9a610d7bb7cd248
Patch-set: 2
File: init/do_mounts.c

561:9-561:24
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6a6fdc1_b20b7e66
Bytes: 480
This means that the verity_table cannot contain layered dm targets. E.g.
dm-0=dm-bootcache
dm-1=dm-verity

Is there a reason not to leave root= alone (e.g., have the cmdline populate it as root=/dev/dm-0) and add a new commandline flag to pass in anything needed?  If not, it would make sense to have the new root be set by dm_run_setup().


I'd prefer not as a magic root= value is harder to debug than having a known one and an explicit parameter that sets up what it points at.

561:9-561:24
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6a6fdc1_b20b7e66
UUID: 76fd65bf_cbfd0922
Bytes: 688
I came to know that the policy in Android is to take the best effort to boot the device to UI(Provided that we already have warned the user). With that in mind, I was thinking that the root= can carry the actual device name and if the dm-setup succeeds we would replace the saved_root_name with /dev/dm-0/ as at least in Android the dm-verity device for the root partition is the first dm-device to be set up. I was not aware of the fact that it's not the case for chrome-os.

sure I can change it to root=/dev/dm-0 and make my verity module take a command line parameter for indicating the actual block device. If dm-setup fails, I can replace the saved root name with block device name.

561:9-561:24
Wed Oct 28 14:58:16 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76fd65bf_cbfd0922
UUID: b6051dc5_173e54f1
Bytes: 1805
Ah yeah. This is an area where I vehemently philosophically disagree  :)

That aside(!), I have three main reasons I raise this comment:
- magic: anytime a value set by the developer is changed behind the scenes based on some policy logic, it can be fragile and hard to debug.  Making each piece explicit can save hours down the line and avoids surprising anyone.
- development purposes: If I have a system where I can change the kernel commandline, it's nice to be able to repoint it to the non-verity root even if the dm-verity target is still configured and just unused.  It means I can iterate on testing something related to verity without needing to rehash/sign on each iteration (e.g., error reporting handling in userland).
- layered dm targets:  On some chrome os devices, we layer two dm targets. When we do that, we setup both dm-0 and dm-1 and we need to tell the kernel to use /dev/dm-1.  Your code could always just use the "last configured target", but there are cases where we could setup a dm-crypt target during boot too using a system-backed key that we don't boot from and in that case, we'd have to know not to make it the last target (for example).

I'm not going to die on this hill :), but this is the background. I *think* only the first one relates to what android needs -- a way to forcibly keep booting even if device mapper fails.  In that case, a strcpy in the setup-fail path might be less surprising.  Alternatively, you could leave root=[underlying-block-device] and add two cmdline params: dm-root=[dm-minor-number] and dm-root-passthrough=1 (or whatever0.  Then if there is no dm-root, it just boots the real root and if there is a large number of dm targets brought up it picks the dm-[minor].  (Or any number of other combos of params and settings - just a strawman :)

File: init/do_mounts.h

80:0-80:4
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6b795e1_c2b3d321
Bytes: 40
init __init dm_run_setup(char *rootdev);

84:7-84:11
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_136b576b
Bytes: 176
q: a 'static' defined as __init section is probably meaningless, but it does clearly state to the developers that whatever code it produces could disappear later? Just curious.

File: init/do_mounts_android_verity.c

53:9-53:18
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6f27de4_52879214
Bytes: 218
with this here, why replace root=?

Also, going down this route makes this patch very specialized.  IMO, it'd be better to break it up into a dm="" style patch then add a new table-type for DM for android-style verity.

53:9-53:18
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6f27de4_52879214
UUID: b68efd7e_0f01c586
Bytes: 95
I saw one major blocker for adding a custom target.  I have described it in the "Reply" section

70:44-70:61
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_bcd369e5
Bytes: 152
this looks like similar code to kernel/module_signing.c.  Is there a chance (later) to share code so this doesn't block the on-flash size of the kernel?

70:44-70:61
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c81977_bcd369e5
UUID: b640bdd4_48fed3c8
Bytes: 323
I can.. But, I thought that would be the last step, when we are very close to merging this upstream, as It might be hard to merge patches involving module_signing if I refactored the module_sgining code. Until this gets merged upstream, the version here always has the risk of diverging from the one used in module_signing.

104:30-104:33
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_9cd6add6
Bytes: 133
nit: This would give me less of the heebie jeebies if it didn't rely on type +1 behavior. E.g.,
   desc = (void *)pks + sizeof(*pks);

104:30-104:33
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c81977_9cd6add6
UUID: 76fd65bf_c5a4dae1
Bytes: 376
void * pointer math is defined as illegal in the C specification. You must use u8 *. There can be debate over all styles of pointer math ... :-(

6.2.5-19: The void type comprises an empty set of values; it is an incomplete type that cannot be completed.
Since void is an incomplete type, it is not an object type. Therefore it is not a valid operand to an addition operation.

176:28-176:34
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36bdadca_d6c3a2bd
Bytes: 126
does pr_init_info annotate with the calling func or file? If not, it'd be good to note that this is verity_create_dev waiting.

183:2-183:24
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_54416221
Bytes: 67
why is this code cargoculted from  do_mounts.c:prepare_namespace()?

189:15-189:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56c22158_d7a9de52
Bytes: 19
debugging leftoves?

208:0-208:68
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 968d7947_f4ec10eb
Bytes: 117
Whoa - cool.  Is this safe during early boot? I had assumed you'd  have to just grab the sectors with a bio directly.

208:0-208:68
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 968d7947_f4ec10eb
UUID: 56fce1c4_8df849e8
Bytes: 129
sys_open, sys_read, sys_lseek are used in init/do_mounts_rd.c which is called during init as well. Do you see some problem here ?

325:5-325:16
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6f27de4_12910a4c
Bytes: 526
so if the phone is unlocked, it'll just passthrough? And the kernel parameters are bootloader specific, right?

In this scenario there are two trusted parties:
- signed data on disk
- kernel command line
where the latter has the priority since the disabled bit on disk isn't a signed bit.

Is this the intention?  If so, why does the kernel have to do all the signing and not leave it in one trusted place -- the bootloader/handoff?

If it's because of legacy secure bootloaders, we still expect good signals on locked status?

325:5-325:16
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6f27de4_12910a4c
UUID: 7642c5df_863850b6
Bytes: 817
The locked status is obtained from androidboot.veritystate. This is something that is mandated in the bootloader requirements and this kernel module is not the primary consumer of that. So we are trusting this signal anyways. http://source.android.com/devices/tech/security/verifiedboot/verified-boot.html has more details.

Verity cannot be disabled on real world user devices.  Real world user devices are always in the locked state. If its unlocked we don't ensure the integrity of the device. If the magic_number is set to anything other than "VERITY_METADATA_MAGIC_NUMBER" in a user build, we know that verity images can no longer be trusted.

The signed metadata is placed in the same partition as the data blocks, so that we dont have any dependency between creating the verity partition images and the kernel.

429:19-429:33
Wed Oct 21 11:37:42 2015 +0000
Author: Sami Tolvanen <1058768@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b988aea5_dff25b98
Bytes: 132
In fs_mgr_setup_verity, we also mark the underlying device as read-only after dm-verity has been set up. Should we do the same here?

429:19-429:33
Wed Oct 21 22:58:45 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b988aea5_dff25b98
UUID: 194a9a42_d8a7c528
Bytes: 451
I think we are doing that as well !!

fs_mgr seems to call into fs_mgr_set_blk_ro which makes a BLKROSET ioctl.. drivers/md/md.c seems to service this by calling into set_disk_ro.

In our kernel module, do_mounts_verity.c directly calls set_disk_ro(line 53). Verity_args.ro argument is hardcoded to 1. So, we always mark this read only as long as we are mounting the blkdevice through dm.

Let me know if this is not suffice or If am missing something

457:0-457:63
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_943aeaac
Bytes: 70
Is there another way to do this without duplicate device waiting, etc?

458:15-458:21
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_900e7a77
Bytes: 67
It's not the rootdev though is it? It's the metadata device, right?

458:15-458:21
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76880537_900e7a77
UUID: f636b56e_67bae648
Bytes: 215
It is the rootdev. In Android, we have all the three verity pieces in the same partition. The data blocks, verity hash tree and the signed metadata which is used to setup the partition are all in the same partition.

468:23-468:26
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_7c9b913f
Bytes: 133
nit: it'd be nice to pass around the struct being used and not assume global access just from style perspective. (Here and elsewhere)

479:2-479:6
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6a6fdc1_92575a3b
Bytes: 108
any reason to have an else here and not just:
    if (verity...)
      goto err_vrity_table;
    goto err;
?

502:44-502:47
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36f76de3_63b4020b
Bytes: 227
this string should go into the init section ;-}

can be defined locally within this block:

while (i < VERITY_TABLE_ARGS) {
    static const char delim[] __initconst = " ";

    verity_table_args[i] = strsep(&table_ptr, delim);

526:16-526:28
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56c22158_576f8eba
Bytes: 87
would be good to check that this doesn't wrap (though the result will be checked by dm)

547:16-547:23
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_b00b7666
Bytes: 62
out of curiosity, why is vmalloc() being used everywhere here?

547:16-547:23
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76880537_b00b7666
UUID: d6ae1193_989b0a3f
Bytes: 366
Does not draw from the precious physically contiguous pool of pages from the slab allocator or dma resources. The main advantages of using vmalloc show up when accessing more than a page size though ...

Also, vmalloc does not incite a kernel panic when starved for memory (but typically you have a fallback plan, like using a smaller buffer, or less functionality).

File: init/do_mounts_android_verity.h

1:8-1:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76880537_f0ec1eeb
Bytes: 12
boilerplate?

55:7-55:19
Tue Oct 27 20:32:32 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 964739ec_9e9f3d5c
Bytes: 49
;-}

/* Yes, this is freed before exiting init */

56:28-56:29
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56e941ce_066ddbed
Bytes: 225
Beware of holes in structures? __packed to be sure?

metadata_start 'starts' on a u32 boundary as it stands, can the structure be refactored so that metadata_start and verity_table pointer are guaranteed on a 64-bit boundary?

78:0-78:14
Tue Oct 27 20:01:28 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6d8bd3b_ded9f455
Bytes: 28
starts on a 32-bit boundary.

File: init/do_mounts_verity.h

1:19-1:31
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 169a6978_d5d0eeda
Bytes: 11
boilerplate

7:8-7:20
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f69cf575_b437eec5
Bytes: 31
is this standard anywhere else?

7:8-7:20
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f69cf575_b437eec5
UUID: f636b56e_87b7ea5d
Bytes: 232
This is inspired from the discussion that is happening upstream.
http://www.serverphorums.com/read.php?12,963491
The patches mentioned in the email thread have not been merged yet. Using them directly made me hit compilation issues.

24:17-24:24
Tue Oct 27 20:32:32 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 964739ec_3ed4e91a
Bytes: 6
__init

26:30-26:31
Tue Oct 27 20:32:32 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f636b56e_61417670
Bytes: 10
__init (?)

27:9-27:27
Tue Oct 27 20:32:32 2015 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16342965_e2102669
Bytes: 17
missing closing )

45:5-45:17
Tue Oct 27 16:27:02 2015 +0000
Author: Will Drewry <1022354@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c81977_bc9c4936
Bytes: 196
If you only ever setup one target, you don't need a lot of the work here.  Of course, if you only setup one target, then this patch set will definitely not be compatible with usage in chrome os :/

45:5-45:17
Wed Oct 28 09:31:47 2015 +0000
Author: Badhri Jagan Sridharan <1042384@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c81977_bc9c4936
UUID: 964739ec_6425febf
Bytes: 68
Happy to help to find a middle ground between chrome-os and Android.

