Revision: 110bb8cfe9401ce5e0f5f0b5702655d39512eb53
Patch-set: 12
File: security/selinux/avc.c

231
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_23bbae0a
Bytes: 12
unsigned int

239
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_dee8217f
Bytes: 287
Can simplify the if statement and return statements to:

return 1U & (op->perms[num >> 5] >> (num & 0x1f));

And should likely define a macro that can be reused for both perms and type arrays for bit testing and setting, thereby reducing duplication and centralizing the magic constants.

256
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_a2dedadf
Bytes: 69
Why isn't this always done, even if we had to set the type bit first?

282
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_0304f241
Bytes: 366
Should probably be using the Linux kernel list structures and macros, include/linux/list.h.  AVC already converted to use hlists as appropriate for hash chains.  AVC and security server originally predated Linux and thus didn't use native Linux types and security server policy data structures shared with userspace but for in-kernel structures, should convert over.

313
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_42d0b6ce
Bytes: 28
sizeof(dest->allowed->perms)

324
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_be30b597
Bytes: 74
Maybe this belongs in the caller so it is only applied in the proper case?

346
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_e2e8e27e
Bytes: 3
++;

349
Wed Mar 18 15:00:48 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c6aba49c_fef2e1b3
Bytes: 238
Not necessarily.  Between the time you incremented operations_len in avc_has_operation() and the time we reach here, you have dropped and re-acquired the rcu read lock and thus this entry may in fact have been allocated by another thread!

349
Wed Mar 18 20:41:53 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c6aba49c_fef2e1b3
UUID: c6d48430_f6456076
Bytes: 109
hmm...suggestions? Do I just need due diligence here e.g. check that the operation decision is in fact empty?

349
Thu Mar 19 12:27:04 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c6d48430_f6456076
UUID: a6a6b0d3_ec635314
Bytes: 642
I'm wondering whether the entire approach to allocation of these structures ought to be reconsidered.  Preallocating all fields and then freeing the unused ones seems wasteful, and allocating based on what will effectively be a guess as to the right number of elements since the node may have been updated or even reclaimed and replaced in the interim seems error prone.  Since these entries are allocated with GFP_ATOMIC, the allocation is nonblocking and thus can occur under the spinlock so it would be possible to allocate the new operation_decision and add it to the list here, without relying on having guessed the right number earlier.

353
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_430efa6b
Bytes: 31
Why not insert as the new head?

363
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_de8ca1cf
Bytes: 18
sizeof(dest->type)

491
Mon Mar 16 21:44:58 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c61ac4b3_c072c2df
Bytes: 48
this is an impossible to occur condition, right?

492
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_5e5091b5
Bytes: 90
This kind of test, if necessary/appropriate at all, should be a BUG_ON, i.e. an assertion.

526
Thu Mar 19 15:25:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6a6b0d3_0c40bff4
Bytes: 336
Maybe we should defer the allocation of the operations until we know the actual length, e.g. during populate.  The only real reason we allocate the node up front is a) that allocation does not have any dependencies, and b) if we reach the threshhold, we run a reclaim scan.  But allocation of the operations could occur during populate.

797
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_23300e1b
Bytes: 8
spelling

861
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_a205facb
Bytes: 147
Didn't you say that a cmd==0 is possible for an ioctl?  If so, you need a separate parameter or other way to determine whether this should be done.

977
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_832f22b8
Bytes: 66
inlined and only called once, and short enough to inline directly?

1000
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_7ecc6d08
Bytes: 45
Small function, one caller.  Inline directly?

1025
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_5ec7b1e4
Bytes: 41
No callers within this file.  Why inline?

1054
Thu Mar 19 15:25:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86b52cfa_d0770c89
Bytes: 373
node can be NULL here from avc_compute_av().
We should only use the avd and ops structures here.
Not sure even why we are returning node from avc_compute_av() as it wasn't being used by avc_has_perm; probably legacy.  The AVC is a cache, so it is always ok to not save the entry if we have a memory allocation failure, but we always get a response from the security server.

1054
Thu Mar 19 15:36:05 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 86b52cfa_d0770c89
UUID: 86b52cfa_308990f4
Bytes: 350
commit 21193dcd1f3570ddfd8a04f4465e484c1f94252f removed the conditional use of node if non-NULL.  We should just make avc_insert() and avc_compute_av() void functions as nothing is using the return value and nothing should depend on a successful AVC insertion.  Only the avd (and now ops) structures returned via parameters should be used by callers.

1134
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_c3204ac7
Bytes: 72
Should likely introduce a flag or specific parameter to indicate no-cmd.

File: security/selinux/include/security.h

37
Wed Mar 18 12:43:39 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_f14990bd
Bytes: 325
Policy version 30 was just allocated upstream for a change in the Xen policy format, but the current definition for SELinux kernel policy is identical to policy 29, so you can still reuse version 30 for your change as long as it lands before we make another release of the selinux userspace (wouldn't expect one for a while).

117
Tue Mar 17 15:08:55 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_62793246
Bytes: 262
This field is never used or set by the security server (ss/*.h), so it doesn't belong in security.h or as part of this interface.  It belongs in a AVC-private data structure that wraps the operation_decision returned by the security server and adds it to a list.

128
Tue Mar 17 15:08:55 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_1e036993
Bytes: 6
Ditto.

File: security/selinux/ss/avtab.c

467
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_a20c1af0
Bytes: 186
Not sure we need the version check in the kernel writer code since the policy can only originate from a prior load and the reader code prohibits AVTAB_OP unless the vers >= this version.

487
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_5e9ed1e4
Bytes: 24
ARRAY_SIZE(ops.op.perms)

569
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6da3033_031b129f
Bytes: 10
ARRAY_SIZE

File: security/selinux/ss/services.c

569
Wed Mar 18 14:31:32 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c6aba49c_1e7a2db7
Bytes: 196
We should go ahead and pass ops to type_attribute_bounds_av() and adjust it for bounded types, and define and pass a lo_ops struct here to use for masking out operations not allowed to the parent.

569
Wed Mar 18 20:41:53 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c6aba49c_1e7a2db7
UUID: e6bd08e7_9192ac23
Bytes: 228
Some name overloading on the word "type." Perhaps I should change to code/function from type/number...

As-is, we would only be able to consider ioctl command types, not the numbers, as the numbers are looked up later as needed.

569
Thu Mar 19 12:44:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e6bd08e7_9192ac23
UUID: c6aba49c_07d1bc83
Bytes: 743
If you define:

typebounds A B;

typebounds B C;

in policy, then C can only be allowed a subset of permissions of B, and B can only be allowed a subset of permissions of A.  The type_attribute_bounds_av() function enforces this restriction in the kernel, and this relationship is relied upon by certain SELinux hooks to guarantee that a context is no more privileged than another context, checked via security_bounded_transition().  So with this new construct of allowed operations, unless we extend the logic to also remove any operation types and/or numbers not permitted to the ancestor domains, then it becomes possible for a bounded type to be allowed more than its parent.  Can be done as a separate change on top but wanted to note it.

626:18-626:19
Mon Mar 16 21:44:58 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86144c89_58a6cd8c
Bytes: 43
extract out and make a #define out of this?

626:18-626:19
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 86144c89_58a6cd8c
UUID: a6da3033_235f2e53
Bytes: 21
ARRAY_SIZE(ops->type)

627
Wed Mar 18 14:35:45 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86b52cfa_dc63ad14
Bytes: 177
Not sure if I am just misunderstanding, but this looks wrong.  Setting op->type[i] from a perms[i] value?  Don't you just want to set the type value at this point in both cases?

627
Wed Mar 18 20:41:53 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 86b52cfa_dc63ad14
UUID: 06f05cdb_301e4890
Bytes: 249
AVTAB_OPTYPE is a way to allow entire types. Since there are 256 of them, using the perms value works nicely.

AVTAB_OPNUM is for allowing permissions within a type.

Would you prefer a separate structure since the type value is unused in this case?

627
Thu Mar 19 12:44:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 06f05cdb_301e4890
UUID: 86b52cfa_30a87083
Bytes: 22
Might be clearer, yes.

631
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_9e9779c4
Bytes: 69
Use a common macro for getting/setting bits in type and perms arrays.

661
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_e21622fe
Bytes: 10
ARRAY_SIZE

662
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86e9acd1_0214eef3
Bytes: 48
Do we need this initialization if ops->len == 0?

701
Wed Mar 18 14:31:32 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 86b52cfa_5cfafdb9
Bytes: 103
Should pass ops down to the cond_compute_av and adjust it there as well based on any conditional rules.

701
Wed Mar 18 20:41:53 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 86b52cfa_5cfafdb9
UUID: 06f05cdb_5021ccc7
Bytes: 147
Agreed. My preference would be to limit the scope of this patch and save that as an extension. I'm a bit concerned about how large this is getting.

701
Thu Mar 19 12:44:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 06f05cdb_5021ccc7
UUID: 86b52cfa_d08dcc35
Bytes: 259
I think it is a fairly trivial change to cond_compute_av() that logically fits with this one, and unless you are doing something to prevent it in your checkpolicy patch, it is already possible for these operations to be specified in the conditional avtab too.

936
Tue Mar 17 15:06:51 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66e4b8f7_de9101cf
Bytes: 25
Needed if specified == 0?

948
Wed Mar 18 14:41:12 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a6a6b0d3_bde1ffc5
Bytes: 57
Why is this only if AVTAB_OPNUM and not for AVTAB_OPTYPE?

948
Wed Mar 18 20:41:53 2015 +0000
Author: Jeffrey Vander Stoep <1054468@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a6a6b0d3_bde1ffc5
UUID: 46e6d429_f2f208b4
Bytes: 143
OPTYPE allows an entire type so we care about any specified=OPTYPE that we find, whereas we only care about matching types for specified=OPNUM.

948
Thu Mar 19 12:44:59 2015 +0000
Author: Stephen Smalley <1010111@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 46e6d429_f2f208b4
UUID: 86b52cfa_10945442
Bytes: 111
Don't you have to check somewhere that the od->type matches one of the bits set in node->datum.u.ops->op.perms?

